\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{csquotes}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage[spanish]{babel}
\usepackage[
backend=bibtex,
style=alphabetic,
sorting=ynt
]{biblatex}
\addbibresource{bibl.bib}
\usepackage{float}
\restylefloat{table}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkClass}
\chead{\hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
    \nobreak\extramarks{Problema \arabic{#1} (continuaci\'on)}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problema \arabic{#1} (continuaci\'on)}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problema \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problema \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problema \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Tarea\ \#3}
\newcommand{\hmwkDueDate}{Diciembre 8, 2020}
\newcommand{\hmwkClass}{Estructuras Discretas}
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Profesora Alma Ar\'evalo Loyola}
\newcommand{\hmwkAuthorName}{\textbf{Sof\'ia Guadalupe Alatorre Méndez} \and \textbf{Diego Navarro Macías} \and \textbf{Edson Jair Morales Hernández}}


%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Entregar\ el\ \hmwkDueDate\ a las 11:59pm}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}
https://www.overleaf.com/project/5fcee573c47c2ff436630e54

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Parte \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solución}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}


\maketitle

\pagebreak

\section{Introduction}

\begin{homeworkProblem}
\item ¿Qué es una definición recursiva?\\
\\
\solution\\
\\
Una definición recursiva (o definición inductiva) en lógica matemática y ciencias de la computación se utiliza para definir los elementos de un conjunto en términos de otros elementos del conjunto.\\

La definición recursiva de una función define los valores de las funciones para algunas entradas en términos de los valores de la misma función para otras entradas. \\
\end{homeworkProblem}

\begin{homeworkProblem}
 \item ¿Qué quiere decir que un conjunto sea recursivo?\\
\\
\solution\\
\\
En teoría de la computabilidad, un conjunto B es recursivo, computable o decidible (recurrente primitivo) cuando su función característica es computable total. Esto significa que la función característica, la cual es un predicado, toma valor 1 (cierto) para todos los elementos del conjunto y 0 (falso) para el resto. \cite{martinez2015jerarquia}  \\

\item Menciona tres consecuencias para las Ciencias de la Computación
  si las definiciones recursivas no existieran.\\
  \\
  \begin{itemize}
      \item No existirían las estructuras de datos dinamicos tales como las listas y los árboles.
      \item Sería más complejo hacer programas que se necesitan repetir demasiadas veces.
      \item Se necesitarían un mayor número de instrucciones para que finalmente se pueda compilar el programa. 
  \end{itemize}
  \end{homeworkProblem}
  
\begin{homeworkProblem}
 ¿De qué manera se relacionan la inducción y la recursión?\\
\\
\solution\\
\\
La recursividad y la inducción —su base matemática— son dos pilares fundamentales en la
formación y en la praxis de un informática y en particular en las de un ingeniero de software.
Cuando se aplica a algoritmos, la recursión se define como una técnica general de resolución de
problemas que consiste en descomponer un problema dado en subproblemas de tamaño menor
pero con la misma estructura que el problema original. La filosofía opuesta es la iteración,
donde se resuelve un problema aplicando procedimientos de solución repetidamente y que no
aprovechan la posible estructura interna del problema. La recursión aparece en otros campos
de la informática aparte de la algorítmica, por ejemplo, en la definición de estructuras de datos.
Sin embargo, la recursión es algo mucho más abstracto que eso y se refiere a objetos que tienen
una estructura autorreferencial, esto es, una estructura compuesta de las mismas estructuras
a escala menor. La recursión es, en su máximo esplendor, una manera de resolver problemas.
Esta consiste en detectar en primer lugar esa estructura recursiva y explotar esa estructura
para resolverlo eficiente y elegantemente.\cite{lara1999induccion} \\
 \end{homeworkProblem}
 
\begin{homeworkProblem}
\item Enuncia el principio de inducción para los \emph{árboles binarios}.\\
\\
\solution\\
\\
Para poder demostrar el principio de inducción sobre árboles, tomamos un árbol T y hacemos:\\
\begin{itemize}
    \item Nuestro case base: sea $void$ un árbol binario, se dice que este cumple la propiedad.
    \item $H.I$: si $T1$ y $T2$ árboles binarios, se dice que estos tambien cumplen la propiedad.
    \item Se prueba que se cumple $(T1,a,T2)$.
\end{itemize}

\item Enuncia el principio de inducción para las \emph{listas}.\\

Si queremos hacer inducción sobre listas, tomamos en cuenta que:
\begin{itemize}
    \item Hacemos nuestro caso base que vendría siendo para la lista vacía, es decir, comprobamos que la propiedad se cumple para la lista vacía.
    \item Nuestra $H.I$ se aplicaría para $xs$.
    \item Para seguir con el paso inductivo, tomamos nuestra $H.I$, para demostrar que se cumple para $(x:xs)$
\end{itemize}
\end{homeworkProblem}

\begin{homeworkProblem}
 \item Realiza los recorridos \emph{preorden, inorden y postorden}
  en el siguiente árbol binario:
  \begin{figure}[h!]
    \centering
    \includegraphics[scale=0.8]{arbored.pdf}
  \end{figure}

\\
\begin{itemize}
\item Sabiendo que el recorrido $preorden$ es de la forma: $raíz$, $hi$, $hd$. Se vería de la sig. manera:\\
$A,B,D,E,G,C,F,H,I$.
\item Sabiendo que el recorrido $inorden$ es de la forma: $hi$, $raíz$, $hd$. El recorrido sería el sig:\\
$D,B,G,E,A,C,H,I,F$.
\item Ahora para hacer el recorrido $postorden$ de la forma: $hi$, $hd$, $raíz$. Quedaría de la sig. manera:\\
$D,G,E,B,I,H,F,C,A$.
\end{itemize}
\end{homeworkProblem}

\begin{homeworkProblem}
 \item Demuestra las siguientes propiedades de las listas:\\
 $length(rev(x:xs)) = length(x:xs)$\\
 Esta formula se demostraría de la sig. manera:\\
 Tonamos nuestro case base que sería para la lista vacía:\\
 $xs$= []. Queremos demostrar que:\\ 
 $length(rev(x:[])) = length(x:[])$.\\
 Al utilizar la definición de reversa quedaría: \\
 $length(rev[] ++ [x])$ =  $length([] ++ [x])$ = $length[x]$.\\
 Hacemos nuestra hipótesis de inducción para: \\
 $length(rev(xs)) = length(xs)$.\\
 Y hacemos nuestro paso inductivo:\\ 
 $length(rev(x:xs)) = length(x:xs)$\\
Utilizamos definición de reversa: $length((xs)++[x])$ =\\ $length(xs:x)$
\end{homeworkProblem} 
\pagebreak
\printbibliography




\end{document}
