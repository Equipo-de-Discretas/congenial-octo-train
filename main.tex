\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{csquotes}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage[spanish]{babel}
\usepackage[
backend=bibtex,
style=alphabetic,
sorting=ynt
]{biblatex}
\addbibresource{bibl.bib}
\usepackage{float}
\restylefloat{table}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkClass}
\chead{\hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
    \nobreak\extramarks{Problema \arabic{#1} (continuaci\'on)}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problema \arabic{#1} (continuaci\'on)}{Problema \arabic{#1} continua en la p\'agina siguiente\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problema \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problema \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problema \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Tarea\ \#2}
\newcommand{\hmwkDueDate}{Noviembre 11, 2020}
\newcommand{\hmwkClass}{Estructuras Discretas}
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Profesora Alma Ar\'evalo Loyola}
\newcommand{\hmwkAuthorName}{\textbf{Sof\'ia Guadalupe Alatorre Méndez} \and \textbf{Diego Navarro Macías} \and \textbf{Edson Jair Morales Hernández}}


%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Entregar\ el\ \hmwkDueDate\ a las 11:59pm}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}


\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Parte \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solución}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}


\maketitle

\pagebreak

\begin{homeworkProblem}
¿Qué es una definición recursiva?\\
\\
\solution\\
\\
Una definición recursiva (o definición inductiva) en lógica matemática y ciencias de la computación se utiliza para definir los elementos de un conjunto en términos de otros elementos del conjunto.\\

La definición recursiva de una función define los valores de las funciones para algunas entradas en términos de los valores de la misma función para otras entradas. \\
\end{homeworkProblem}

\begin{homeworkProblem}
¿Qué quiere decir que un conjunto sea recursivo?\\
\\
\solution\\
\\
En teoría de la computabilidad, un conjunto B es recursivo, computable o decidible (recurrente primitivo) cuando su función característica es computable total. Esto significa que la función característica, la cual es un predicado, toma valor 1 (cierto) para todos los elementos del conjunto y 0 (falso) para el resto.\\
\\
\end{homeworkProblem}

\begin{homeworkProblem}
¿De qué manera se relacionan la inducción y la recursión?\\
\\
\solution\\
\\
La recursividad y la inducción —su base matemática— son dos pilares fundamentales en la
formación y en la praxis de un informática y en particular en las de un ingeniero de software.
Cuando se aplica a algoritmos, la recursión se define como una técnica general de resolución de
problemas que consiste en descomponer un problema dado en subproblemas de tamaño menor
pero con la misma estructura que el problema original. La filosofía opuesta es la iteración,
donde se resuelve un problema aplicando procedimientos de solución repetidamente y que no
aprovechan la posible estructura interna del problema. La recursión aparece en otros campos
de la informática aparte de la algorítmica, por ejemplo, en la definición de estructuras de datos.
Sin embargo, la recursión es algo mucho más abstracto que eso y se refiere a objetos que tienen
una estructura autorreferencial, esto es, una estructura compuesta de las mismas estructuras
a escala menor. La recursión es, en su máximo esplendor, una manera de resolver problemas.
Esta consiste en detectar en primer lugar esa estructura recursiva y explotar esa estructura
para resolverlo eficiente y elegantemente. \\
\end{homeworkProblem}

\begin{homeworkProblem}
Enuncia el principio de inducción para las \emph{listas}.
\\
\solution\\
\\
Si queremos hacer inducción sobre listas, tomamos en cuenta que:
\begin{itemize}
    \item Hacemos nuestro caso base que vendría siendo para la lista vacía, es decir, comprobamos que la propiedad se cumple para la lista vacía.
    \item Nuestra $H.I$ se aplicaría para $xs$.
    \item Para seguir con el paso inductivo, tomamos nuestra $H.I$, para demostrar que se cumple para $(x:xs)$
\end{itemize}
\end{homeworkProblem}

\begin{homeworkProblem}
Realiza los recorridos \emph{preorden, inorden y postorden}
  en el siguiente árbol binario:
  \begin{figure}[h!]
    \centering
    \includegraphics[scale=0.8]{arbored.pdf}
  \end{figure}
\solution\\
\\
\begin{itemize}
\item Sabiendo que el recorrido $preorden$ es de la forma: $raíz$, $hi$, $hd$. Se vería de la sig. manera:\\
$A,B,D,E,G,C,F,H,I$.
\item Sabiendo que el recorrido $inorden$ es de la forma: $hi$, $raíz$, $hd$. El recorrido sería el sig:\\
$D,B,G,E,A,C,H,I,F$.
\item Ahora para hacer el recorrido $postorden$ de la forma: $hi$, $hd$, $raíz$. Quedaría de la sig. manera:\\
$D,G,E,B,I,H,F,C,A$.
\end{itemize}
\end{homeworkProblem}

\pagebreak

\cite{miquelteorias,lodepe}
\printbibliography


\end{document}
